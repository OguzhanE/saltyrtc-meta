# SaltyRTC - Secure WebRTC/ORTC based on NaCl

# Abstract

SaltyRTC is a protocol for WebRTC and ORTC which uses end-to-end
encryption techniques based on the Networking and Cryptography library
(NaCl) and the WebSocket protocol to set up a secure peer-to-peer
connection. The protocol has been designed in a way that no third party
needs to be trusted. Furthermore, it offers another security layer for
WebRTC and ORTC Data Channels.

This document describes the protocol for both client (a peer wanting
to set up a WebRTC or ORTC connection) and server (relays signalling
data from one client to another).

# Introduction

TODO

# Conventions

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in
[RFC 2119 [RFC2119]](https://tools.ietf.org/html/rfc2119).

# Terminology

## Client

A SaltyRTC compliant client. The client uses the signalling channel to
establish a WebRTC or ORTC peer-to-peer connection.

## Server

A SaltyRTC compliant server. The server provides the signalling channel
clients may communicate with one another.

## Peer

The term *peer* is being used for protocol descriptions that need to
be followed by both SaltyRTC compliant clients and servers.

## Initiator

An initiator is a SaltyRTC compliant client who wants to establish a
WebRTC or ORTC peer-to-peer connection to a responder.

## Responder

The responder is a SaltyRTC compliant client who wants to establish a
WebRTC or ORTC peer-to-peer connection to an initiator.

## Signalling Path

A signalling path is a simple ASCII string and consists of the hex
value of the initiators public key. Initiator and responder connect
to the same WebSocket path.

## MessagePack Object

MessagePack is an object serialisation format very similar to JSON but 
uses a binary format. The MessagePack specification can be found 
[here](https://github.com/msgpack/msgpack/blob/0b8f5ac67cdd130f4d4d4fe6afb839b989fdb86a/spec.md).

## NaCl Key Pairs

NaCl (pronounced *salt*) is the Networking and Cryptography library 
which is being utilised by SaltyRTC to encrypt and authenticate its 
messages. See [nacl.cr.yp.to](https://nacl.cr.yp.to) for details.

In this specfication, we will use both secret and public key 
authenticated encryption provided by NaCl.

NaCl key pairs SHALL always be generated by using a cryptograhically 
secure random number generator.

## Client's Permanent Key

The permanent key is a NaCl key pair for public key authenticated 
encryption. Each client MUST have or generate a permanent key that is 
valid beyond sessions.

## Server's Session Key

A SaltyRTC compliant server MUST generate a new NaCl key pair for 
public key authenticated encryption **for each connected client**. 
The key is being exchanged in the handshake and is valid for the 
lifetime of the connection.

## Client's Session Key

A SaltyRTC compliant client MUST generate a new session NaCl key pair 
for public key authenticated encryption **for each other client**. 
More precisely:

* An initiator MUST generate such a key pair for each responder that 
has sent a valid 'token' message during the client-to-client 
authentication process.
* A responder MUST generate such a key pair for the initiator once it 
has received a valid 'key' message during the client-to-client 
authentication process.

The key pair is valid for the lifetime of the client-to-client 
connection.

## Authentication Token

An authentication token consists of a NaCl secret key that is valid 
for a single encrypted message during the authentication process 
between initiator and responder. The token MUST be exchanged over a 
secure channel which is not defined in this document.

## Address

The address is a single byte that identifies a specific peer on a
WebSocket path. It is being used to indicate to which client a server
should relay a message. In this document, the byte will be represented
in hexadecimal notation (base 16) starting with `0x`.  
The server (`0x00`) and the initiator (`0x01`) have a static
identifier. For responders, the server MUST dynamically assign
identifiers (in the range of `0x02..0xff`). A server-assigned address 
becomes invalid as soon as the connection to the server has been 
severed.

# WebSocket

The SaltyRTC protocol has been designed to work on top of the WebSocket
protocol. For more information about the WebSocket protocol, see
[RFC 6455 [RFC6455]](https://tools.ietf.org/html/rfc6445).

## Security Recommendation

Although the SaltyRTC protocol takes many security measures to prevent 
eavesdropping, it is still highly RECOMMENDED to use WebSocket in its 
*secure* mode (e.g. provide a valid certificate). This measure will 
ensure that the signalling path is hidden from eavesdroppers and 
generally hardens the protocol against potential attacks.

## Subprotocol

It is REQUIRED to provide the following subprotocol when connecting to
a server:

`v0.saltyrtc.org`

Only if the server chose the subprotocol above, this protocol
SHALL be applied. If another shared subprotocol that is not related to 
SaltyRTC has been found, continue with that subprotocol. Otherwise, 
close the connection to the server with a close code of `1002` (No 
Shared Subprotocol Found).

TODO: Switch to `v1` as soon as the spec has been reviewed.

# Message Structure

SaltyRTC messages are encoded in binary using network-oriented format 
(most significant byte first, also known as *big-endian*). Unless 
otherwise noted, numeric constants are in decimal (base 10).

All signalling messages MUST start with a 24-byte nonce followed by
either:

* an NaCl public-key authenticated encrypted MessagePack object,
* an NaCl secret-key authenticated encrypted MessagePack object or
* an unencrypted MessagePack object.

Which case applies is always known by the communicating parties. In
some scenarios, more than one case is possible. For these scenarios, a
description will be provided how multiple cases must be handled.

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    |                                                               |
    |                            Nonce                              |
    |                                                               |
    |                                                               |
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                             Data                          ...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

The nonce is exactly 24 byte that SHALL only be used once per shared
secret. A nonce can also be seen as the **header** of SaltyRTC messages
as it is used by every single signalling message. It contains the
following fields:

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    |                            Cookie                             |
    |                                                               |
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |    Source     |  Destination  |        Overflow Number        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                        Sequence Number                        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Cookie: 16 byte

This field contains 16 cryptographically secure random bytes. For 
SaltyRTC clients, the cookie MUST remain the same during the 
connection to the signalling path. However, SaltyRTC servers MUST 
generate and use a random cookie for each client.

Source: 1 byte

Contains the SaltyRTC address of the sender.

Destination: 1 byte

Contains the SaltyRTC address of the receiver.

Overflow Number: 2 byte

This field contains the 16 bit unsigned overflow number used in
combination with the sequence number. Starts with `0`.

Sequence Number: 4 byte

Contains the 32 bit unsigned sequence number. Starts with a
cryptographically secure random number and MUST be incremented by `1`
for each message.

Note: The overflow and the sequence number have been defined separately
considering that some programming languages do not have a native 48 bit
unsigned integer type. However, treating the overflow and the sequence
number as a single 48 bit unsigned integer is possible and supported by
this protocol. In further sections, the combined number will be called
*Combined Sequence Number*.

---

# Connecting To a Signalling Server

A server MUST listen and accept incoming WebSocket connections. 
Clients SHALL connect to a server by using the WebSocket protocol and 
supplying a valid signalling path where they want to meet the other 
client. Servers MUST separate communication of clients between paths. 
This will be described in detail in the *Client-to-Client 
Communication* section.

The path MUST be set as part of the WebSocket URI directly after the 
hostname, separated by a forward slash. A signalling path is a simple 
ASCII string and MUST be the lowercase hex value of the initiators 
public key. Therefore, the resulting path MUST contain exactly 64 
characters. Initiator and responder connect to the same WebSocket path.

Example of a WebSocket URI including a valid signalling path:

```
wss://example.com/debc3a6c9a630f27eae6bc3fd962925bdeb63844c09103f609bf7082bc383610
```

# Sending a Signalling Message

A peer that wants to send a signalling message needs to go through the 
process of creating the *nonce* part of the message first.

In case this is the first message sent on a newly established 
client-to-server connection, a random cryptographically secure cookie 
MUST be generated. In case the other peer has already sent a message, 
this cookie MUST be different to the cookie the other peer has used in 
its first message.

Set the source address:

* A server SHALL use `0x00` as source address.
* A client SHALL use its assigned identity as source address. If it 
  has not been assigned an identity yet, the source address MUST be 
  set to `0x00`.

Set the destination address:

* A server SHALL use the identity it has assigned to the client as 
  destination address if the client-to-server authentication process 
  has been completed. Otherwise, the destination address SHALL be 
  `0x00`.
* A client MUST use the identity of the peer the message should be 
  sent to. Initially, initiators and responders SHALL ONLY sent 
  messages to the server (`0x00`). As soon as an identity (address) 
  has been assigned to it, an initiator MAY also send messages to 
  responders (`0x02..0xff`) and a responder MAY also send messages to 
  the initiator (`0x01`).

If this is the first message to the destination peer:

* Set the overflow number to `0` and the sequence number to a 32 bit 
  cryptographically secure random number, or
* Alternatively, if the implementation is using the combined sequence 
  number, the upper 16 bit SHALL be `0` and the lower 32 bit MUST be 
  cryptographically secure random.
* The above number(s) SHALL be stored and updated separately for each 
  other peer by its identity (destination address in this case).

In case this is not the first message to the destination peer, the 
peer does the following:

* In case that the peer does make use of the combined sequence number, 
  it MUST increase the combined sequence number of the destination 
  peer by `1` and check that is has not reset to `0`. Implementations 
  that use the combined sequence number SHALL ignore the following 
  three procedures.
* Increment the sequence number of the destination peer by `1`. In 
  case that it overflows (and resets to `0`), the overflow number of 
  the destination peer MUST be increased by `1` as well, and
* In case the overflow number of the destination peer has been 
  incremented by `1`, it SHALL NOT reset to `0` if it was greater than 
  `0` before.

In case any of the checks listed above failed, the peer MUST close the 
connection with a close code of `3001` (*Protocol Error*).

The peer MUST serialise and encrypt (only if that is required by the 
message type) the MessagePack object. The resulting sequence of bytes 
represents the *data* section of the message and MUST contain more 
than `0` bytes.

The concatenation of the *nonce* and the *data* section represents the 
whole message and SHALL be sent as a whole.

# Receiving a Signalling Message

When a peer receives a signalling message, it first checks that the 
message contains more than 24 byte. It checks that the destination 
address is sane:

* A server MUST check that the destination address is `0x00` until the
  sender is authenticated. In case that the sender is authenticated,
  relaying is ONLY allowed between an initiator (`0x01`) and a 
  responder (`0x02..0xff`).
* A client MUST check that the destination address targets its
  assigned identity (or `0x00` during authentication). The first 
  message received with a destination address different to `0x00` 
  SHALL be accepted and stored as the client's assigned identity.

Furthermore, a peer checks that the source address is sane:

* A server MUST check that the source address is `0x00` until a
  specific identity has been assigned to the sender. In case that the
  sender is authenticated, the server MUST check that the source
  address equals the sender's assigned identity.
* An initiator SHALL ONLY process messages from the server (`0x00`). 
  As soon as the initiator has been assigned an identity, it MAY ALSO 
  accept messages from other responders (`0x02..0xff`). Other messages 
  SHALL be discarded and SHOULD trigger a warning.
* A responder SHALL ONLY process messages from the server (`0x00`). 
  As soon as the responder has been assigned an identity, it MAY ALSO 
  accept messages from the initiator (`0x01`). Other messages SHALL be 
  discarded and SHOULD trigger a warning.

In case this is the first message received from the sender, the peer:

* MUST check that the overflow number of the source peer is `0` (or 
  the upper 16 bits of the combined sequence number of the source peer 
  are `0`, in code: `csn & 0xffff00000000 == 0`) and,
* if the peer has already sent a message to the sender, MUST check that
  the sender's cookie is different than its own cookie, and
* MUST store cookie, overflow number and sequence number (or the
  combined sequence number) for checks on further messages.
* The above number(s) SHALL be stored and updated separately for each 
  other peer by its identity (source address in this case).

Afterwards, a peer MUST check that the 16 byte cookie of the sender has
not changed.

If the message is received by a client or received by and intended for 
a server (the destination address is `0x00`), the peer does the
following checks:

* In case that the peer does make use of the combined sequence number,
  it MUST check that the combined sequence number of the source peer 
  has been increased by `1` and has not reset to `0`. Implementations 
  that use the combined sequence number SHALL ignore the following 
  three checks.
* In case incrementing the sequence number of the source peer would 
  not overflow that number, the sequence number MUST be incremented by 
  `1` and the overflow number of the source peer MUST remain the same.
* In case incrementing the sequence number of the source peer would 
  overflow, the sequence number MUST be `0` and the overflow number of 
  the source peer MUST be increased by `1`.
* The overflow number of the source peer SHALL NOT reset to `0` if it 
  was greater than `0` before.

In case that any check fails, the peer MUST close the connection with 
a close code of `3001` (*Protocol Error*) unless otherwise stated.

The peer MUST proceed by decrypting (only if that is required by the 
expected message type) and unserialising the MessagePack object from 
the *data* section of the message. In case that decryption or 
unserialisation fails (bear in mind that there is a corner case for 
the server when expecting 'client-hello' or 'client-auth'), the peer 
MUST close the connection with a close code of `3001` (*Protocol 
Error*). Further processing depends on the message type described 
below.

# Encrypting a Message

If a message type requires encrypting, the *data* section of the 
message MUST be encrypted by using either NaCl public key cryptography 
or NaCl secret key cryptography. Which case applies depends on the 
message type.

## Public Key Cryptography

Encrypt *data* with the nonce of the *nonce* section, the sender's 
private key and the receiver's public key of the corresponding key 
pair specified by the message type.

## Secret Key Cryptography

Encrypt *data* with the nonce of the *nonce* section and the secret 
key specified by the message type.

# Decrypting a Message

In case the current state of the message flow indicates that a message 
must be decrypted, the *data* section of the message MUST be decrypted 
by using either NaCl public key cryptography or NaCl secret key 
cryptography. Which case applies depends on the current state in the 
message flow.

## Public Key Cryptography

Decrypt *data* with the nonce of the *nonce* section, the sender's 
public key and the receiver's private key of the corresponding key 
pair specified by the message type.

## Secret Key Cryptography

Decrypt *data* with the nonce of the *nonce* section and the secret 
key specified by the message type.

# Client-to-Server Messages

This section describes the various messages that will be exchanged
between server and client.

Client-to-server messages are distinguishable from client-to-client 
messages by looking at the destination address field of the nonce. 
If the destination address is the server's address (`0x00`), the 
message is a client-to-server message.  
Message types between client and server SHALL NOT be repeated.

The messages are serialised MessagePack objects. We will provide an
example for each message in an extended JSON format where a string
value denoted with 'b' indicates that the content is binary data.
For ease of reading, binary data of the examples is represented as a
hex-encoded string. However, binary data SHALL NOT be hex-encoded in
implementations. Unless otherwise noted, all non-binary strings MUST
be interpreted as UTF-8 encoded strings. Furthermore, field values
SHALL NOT be *null*. The *type* field is REQUIRED for all messages. 
Other required fields will be described in the messages' section. In 
case a field is missing or contains invalid data, the incident MUST be 
treated as a protocol error. This also applies to unexpected messages 
that deviate from the message flow.

## Message Flow

TODO
TODO: Visualise where which key pairs are used

## 'server-hello' Message

This message MUST be sent by the server after a client connected to 
the server using a valid signalling path. The server MUST generate a 
new cryptographically secure random NaCl key pair for each client. The 
public key (32 bytes) of that key pair MUST be set in the *key* field 
of this message.

A receiving client MUST check that the message contains a valid NaCl
public key (the size of the key MUST be exactly 32 bytes).

The message SHALL NOT be end-to-end encrypted.

```
{
  "type": "server-hello",
  "key": b"debc3a6c9a630f27eae6bc3fd962925bdeb63844c09103f609bf7082bc383610"
}
```

## 'client-hello' Message

As soon as the client has received the 'server-hello' message, it MUST 
ONLY respond with this message in case the client takes the role of a 
responder. The initiator MUST skip this message. The responder MUST 
set the public key (32 bytes) of the permanent key pair in the *key* 
field of this message.

A receiving server MUST check that the message contains a valid NaCl
public key (the size of the key MUST be exactly 32 bytes).  
Note that the server does not know whether the client will send a 
'client-hello' message (the client is a responder) or a 'client-auth' 
message (the client is the initiator). Therefore, the server MUST be 
prepared to handle both message types at that particular point in the 
message flow. This is also the intended way to differentiate between 
initiator and responder.

The message is NaCl public-key encrypted by the server's public key 
(sent in 'server-hello') and the client's permanent private key.

```
{
  "type": "client-hello",
  "key": b"55e7dd57a01974ca31b6e588909b7b501cdc7694f21b930abb1600241b2ddb27"
}
```

## 'client-auth' Message

After the 'client-hello' message has been sent (responder) or after 
the 'server-hello' message has been received (initiator) the client 
MUST send this message to the server. The client MUST set the 
*your_cookie* field to the cookie the server has used in the nonce of 
the 'server-hello' message.

TODO: Server receives

TODO: Encryption

```
{
  "type": "client-auth",
  "your_cookie": b"af354da383bba00507fa8f289a20308a"
}
```

## 'server-auth' Message

TODO. The message SHALL only be received by SaltyRTC clients.
TODO: Assign identity (by setting destination address), valid until closed, accept (client)
TODO: Validate responder IDs, not twice, in range 0x02..0xff (initiator)

## 'new-initiator' Message

This message does not require any special processing. It SHALL only be
received by SaltyRTC clients in the role of a responder.
TODO: Remove previously stored cookie & CSN if any

## 'new-responder' Message

TODO. It SHALL only be received by SaltyRTC clients in the role of the
initiator.
TODO: Remove previously stored cookie & CSN if any

## 'drop-responder' Message

TODO. The message SHALL only be received by SaltyRTC servers.
TODO: Remove stored cookie & CSN

## 'send-error' Message

TODO: Change 'hash' to 'nonce'. The message SHALL only be received by
SaltyRTC clients.

# Client-to-Client Communication

TODO: Describe the server's task of relaying messages when clients are on the same path.

# Client-to-Client Messages

The following messages are messages that will be exchanged between two
clients (initiator and responder).

Client-to-client messages are distinguishable from client-to-server 
messages by looking at the address fields of the nonce. If both fields 
contain a client address (an address different to `0x00`), the message 
is a client-to-client message.  
SaltyRTC servers MUST relay these messages to the corresponding 
destination. In case the message could not be relayed, the server MUST 
send a 'send-error' message back to the sender (see previous 
section).  
Message types between initiator and responder SHALL be repeated in 
case the sender receives a 'send-error' message from the server.

Identical to client-to-server messages, the messages are serialised 
MessagePack objects. We will provide an example for each message in an 
extended JSON format where a string value denoted with 'b' indicates 
that the content is binary data. For ease of reading, binary data of 
the examples is represented as a hex-encoded string. However, binary 
data SHALL NOT be hex-encoded in implementations. Unless otherwise 
noted, all non-binary strings MUST be interpreted as UTF-8 encoded 
strings. Furthermore, field values SHALL NOT be *null*. The *type* 
field is REQUIRED for all messages. Other required fields will be 
described in the messages' section. In case a field is missing or 
contains invalid data, the incident MUST be treated as a protocol 
error. This also applies to unexpected messages that deviate from the 
message flow.

## Message Flow

TODO
TODO: Visualise where which key pairs are used

## 'token' Message

TODO. The message SHALL only be received by SaltyRTC clients in the
role of the initiator.

## 'key' Message

TODO.

## 'auth' Message

TODO.

# 'close' Message

TODO

# Errors

## Protocol Violation Error

A protocol violation error MUST be treated by closing the connection 
with a close code of `3001` (*Protocol Error*) unless otherwise stated.

# Close Code Enumeration

The following close codes are being used by the protocol:

- 1001: Going Away
- 1002: No Shared Subprotocol Found
- 3000: Path Full
- 3001: Protocol Error
- 3002: Internal Error
- 3003: Handover of the Signalling Channel
- 3004: Dropped by Initiator

---

# Security Mechanisms

## Cookie

The cookie is being used for two things at the same time. It resembles
a challenge that needs to be repeated by the other peer to mitigate 
replay attacks. A peer can thereby prove that he owns the private key
for the public key he transmitted. Furthermore, it should contain
enough randomness to ensure that a nonce is not being reused for a
shared secret as long as the protocol is being followed closely. To
ensure that nonces are unique per shared secret, peers communicating
with one another must choose different cookies.

## Overflow Number and Sequence Number

Both the overflow number and the sequence number ensure that a nonce
remains a *number used once*. Furthermore, in conjunction with the
cookie, they are being used to mitigate replay attacks.

